---
title: "hw01"
output: html_document
---

```{r }

```
# Домашнее задание № 1
## Работа с данными.
По адресу http://www.stats.uwo.ca/faculty/braun/data/rnf6080.dat можно получить набор данных об осадках в Канаде с 1960 по 1980 годы. Необходимо загрузить эти данные при помощи ``read.table``. Воспользуйтесь справкой, чтобы изучить аргументы, которые принимает функция. 
- Загрузите данные в датафрейм, который назовите ``data.df``.
```{r }
data.df <- read.table("http://www.stats.uwo.ca/faculty/braun/data/rnf6080.dat")
```
- Сколько строк и столбцов в ``data.df``? Если получилось не 5070 наблюдений 27 переменных, то проверяйте аргументы.
5070 obs. of 27 variables
- Получите имена колонок из ``data.df``.
```{r }
colnames(data.df)
```
- Найдите значение из 5 строки седьмого столбца.
```{r }
data.df[5, 7]
```
- Напечатайте целиком 2 строку из ``data.df``
```{r }
data.df[2,]
```
- Объясните, что делает следующая строка кода ``names(data.df) <- c("year", "month", "day", seq(0,23))``. 
```{r}
names(data.df)
names(data.df) <- c("year", "month", "day", seq(0,23))
names(data.df) 

```
меняет названия колонок
- Воспользуйтесь функциями ``head`` и ``tail``, чтобы просмотреть таблицу. Что представляют собой последние 24 колонки?
```{r}
head(data.df)
tail(data.df)
```
Последние 24 колонки - осадки за каждый час
- Добавьте новую колонку с названием *daily*, в которую запишите сумму крайних правых 24 колонок. Постройте гистограмму по этой колонке. Какие выводы можно сделать?
```{r}
data.df$daily <- rowSums(data.df[, 4:27])
hist(data.df[, 28])

```
В данных имеются отрицательные значения количества осадков. Их нужно убрать.
- Создайте новый датафрейм ``fixed.df`` в котром исправьте замеченную ошибку. Постройте новую гистограмму, поясните почему она более корректна.
Два возможных решения: обнулить то, что меньше нуля или просто удалить. Что правильнее?
На любой из этих гистограмм нет некорректных значений.
```{r}
fixed.df1 <- data.df
fixed.df1$daily[which(fixed.df1$daily < 0)] = 0
hist(fixed.df1[, 28])

fixed.df2<-subset(data.df,data.df[,"daily"]>=0);
hist(fixed.df2[, 28])

```

## Синтаксис и типизирование
* Для каждой строки кода поясните полученный результат, либо объясните почему она ошибочна.
```{r}
v <- c("4", "8", "15", "16", "23", "42") #символьный вектор
max(v) #сравнение символьное по первому отличающемуся элементу (максимум из 4 8 1 1 2 4 - это 8)
sort(v) #аналогично по первому символу строки
#sum(v) Error in sum(v) : invalid 'type' (character) of argument
sum(as.integer(v))
```
* Для следующих наборов команд поясните полученный результат, либо объясните почему они ошибочна.
```{r}
#векторы
v2 <- c("5",7,12) # элементы вектора одного типа (все стали символьными)
# v2[2] + v2[3] #Error in v2[2] + v2[3] : non-numeric argument to binary operator
as.integer(v2[2]) + as.integer(v2[3])

#В датафреймах и листах элементы могут быть разных типов
#датафреймы
df3 <- data.frame(z1="5",z2=7,z3=12)
df3[1,2] + df3[1,3]

#листы
l4 <- list(z1="6", z2=42, z3="49", z4=126)
l4[[2]] + l4[[4]] #значение
#l4[2] + l4[4] #ссылка
l4[2]
```

## Работа с функциями и операторами
* Оператор двоеточие создаёт последовательность целых чисел по порядку. Этот оператор — частный случай функции ``seq()``, которую вы использовали раньше. Изучите эту функцию, вызвав команду ``?seq``. Испольуя полученные знания выведите на экран:
    1. Числа от 1 до 10000 с инкрементом 372. 
    ```{r}
    seq(1,10000,by=372);

    ```
    2. Числа от 1 до 10000 длиной 50.
    ```{r}
    seq(1,10000,length.out = 50);
    ```
* Функция ``rep()`` повторяет переданный вектор указанное число раз. Объясните разницу между ``rep(1:5,times=3)`` и ``rep(1:5, each=3)``.
```{r}
rep(1:5,times=3) #повторение всей последовательности
rep(1:5, each=3) #повторение поэлементно
```


